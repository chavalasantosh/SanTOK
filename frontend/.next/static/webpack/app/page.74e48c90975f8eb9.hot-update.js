"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeText: function() { return /* binding */ analyzeText; },\n/* harmony export */   compressText: function() { return /* binding */ compressText; },\n/* harmony export */   getMockCompressionAnalysis: function() { return /* binding */ getMockCompressionAnalysis; },\n/* harmony export */   getMockTokenizationResult: function() { return /* binding */ getMockTokenizationResult; },\n/* harmony export */   tokenizeText: function() { return /* binding */ tokenizeText; },\n/* harmony export */   validateTokenization: function() { return /* binding */ validateTokenization; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nconst API_BASE_URL = \"http://localhost:8000\" || 0;\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    timeout: 300000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Request interceptor for logging\napi.interceptors.request.use((config)=>{\n    var _config_method;\n    console.log(\"API Request: \".concat((_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase(), \" \").concat(config.url));\n    return config;\n}, (error)=>{\n    console.error(\"API Request Error:\", error);\n    return Promise.reject(error);\n});\n// Response interceptor for error handling\napi.interceptors.response.use((response)=>{\n    console.log(\"API Response: \".concat(response.status, \" \").concat(response.config.url));\n    return response;\n}, (error)=>{\n    var _error_response, _error_response1, _error_response2, _error_response3;\n    console.error(\"API Response Error:\", error);\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 500) {\n        throw new Error(\"Server error. Please try again later.\");\n    } else if (((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 400) {\n        var _error_response_data;\n        throw new Error(((_error_response_data = error.response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) || \"Invalid request.\");\n    } else if (((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.status) === 404) {\n        throw new Error(\"API endpoint not found. Please check your configuration.\");\n    } else if (((_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status) === 429) {\n        throw new Error(\"Too many requests. Please wait a moment and try again.\");\n    } else if (error.code === \"ECONNABORTED\") {\n        throw new Error(\"Request timeout. Please try again.\");\n    } else if (error.code === \"ECONNREFUSED\") {\n        throw new Error(\"Cannot connect to server. Please check if the backend is running.\");\n    } else {\n        throw new Error(\"Network error. Please check your connection.\");\n    }\n});\nconst tokenizeText = async (text, options)=>{\n    try {\n        const response = await api.post(\"/tokenize\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Tokenization error:\", error);\n        if (error.code === \"ECONNABORTED\") {\n            throw new Error(\"Request timeout. Please try with shorter text.\");\n        }\n        throw error;\n    }\n};\nconst analyzeText = async (text, options)=>{\n    try {\n        const response = await api.post(\"/analyze\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Analysis error:\", error);\n        throw error;\n    }\n};\nconst compressText = async (text, options)=>{\n    try {\n        const response = await api.post(\"/compress\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Compression error:\", error);\n        throw error;\n    }\n};\nconst validateTokenization = async (originalText, tokens, options)=>{\n    try {\n        const response = await api.post(\"/validate\", {\n            original_text: originalText,\n            tokens,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Validation error:\", error);\n        throw error;\n    }\n};\n// Mock data for development when API is not available\nconst getMockTokenizationResult = (text, options)=>{\n    let tokens = [];\n    switch(options.tokenizerType){\n        case \"space\":\n            tokens = text.split(/\\s+/).filter((token)=>token.length > 0);\n            break;\n        case \"word\":\n            // Split on word boundaries, keeping punctuation\n            tokens = text.split(/(\\W+)/).filter((token)=>token.length > 0);\n            break;\n        case \"char\":\n            tokens = text.split(\"\");\n            break;\n        case \"grammar\":\n            // Grammar-aware tokenization - split on sentence boundaries\n            tokens = text.split(/([.!?]+)/).filter((token)=>token.length > 0);\n            break;\n        case \"subword\":\n            // Simple subword tokenization - split on common separators\n            tokens = text.split(/([\\/_\\-\\.])/).filter((token)=>token.length > 0);\n            break;\n        case \"bpe\":\n            // Byte Pair Encoding simulation\n            tokens = text.match(/.{1,3}/g) || [];\n            break;\n        case \"syllable\":\n            // Syllable-based tokenization simulation\n            tokens = text.split(/([aeiouAEIOU]+)/).filter((token)=>token.length > 0);\n            break;\n        case \"frequency\":\n            // Frequency-based tokenization simulation\n            tokens = text.split(/([a-zA-Z]+)/).filter((token)=>token.length > 0);\n            break;\n        case \"byte\":\n            // Byte-level tokenization\n            tokens = Array.from(text).map((char)=>char.charCodeAt(0).toString());\n            break;\n        default:\n            tokens = text.split(/\\s+/).filter((token)=>token.length > 0);\n    }\n    const tokenObjects = tokens.map((token, index)=>({\n            text: token,\n            id: index,\n            position: text.indexOf(token),\n            length: token.length,\n            type: options.tokenizerType,\n            color: \"hsl(\".concat(index * 137.5 % 360, \", 70%, 50%)\")\n        }));\n    return {\n        tokens: tokenObjects,\n        tokenCount: tokenObjects.length,\n        characterCount: text.length,\n        tokenizerType: options.tokenizerType,\n        processingTime: Math.random() * 100 + 50,\n        memoryUsage: Math.random() * 1024 + 512,\n        compressionRatio: Math.random() * 0.5 + 0.3,\n        reversibility: true,\n        fingerprint: {\n            signatureDigit: Math.floor(Math.random() * 10),\n            compatDigit: Math.floor(Math.random() * 10),\n            textValue: Math.floor(Math.random() * 10000),\n            textValueWithEmbedding: Math.floor(Math.random() * 10000)\n        }\n    };\n};\nconst getMockCompressionAnalysis = ()=>[\n        {\n            algorithm: \"RLE\",\n            compressionRatio: 0.45,\n            tokensSaved: 120,\n            percentageSaved: 35.2,\n            reversibility: true\n        },\n        {\n            algorithm: \"Pattern\",\n            compressionRatio: 0.38,\n            tokensSaved: 145,\n            percentageSaved: 42.1,\n            reversibility: true\n        },\n        {\n            algorithm: \"Frequency\",\n            compressionRatio: 0.52,\n            tokensSaved: 98,\n            percentageSaved: 28.7,\n            reversibility: true\n        },\n        {\n            algorithm: \"Adaptive\",\n            compressionRatio: 0.31,\n            tokensSaved: 178,\n            percentageSaved: 51.8,\n            reversibility: true\n        }\n    ];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDUCxLQUFLQyxNQUFNLEtBQUs7WUFDdENTLHdCQUF3QlYsS0FBS08sS0FBSyxDQUFDUCxLQUFLQyxNQUFNLEtBQUs7UUFDckQ7SUFDRjtBQUNGLEVBQUM7QUFFTSxNQUFNVSw2QkFBNkIsSUFBNkI7UUFDckU7WUFDRUMsV0FBVztZQUNYVCxrQkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO1FBQ0E7WUFDRVEsV0FBVztZQUNYVCxrQkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO1FBQ0E7WUFDRVEsV0FBVztZQUNYVCxrQkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO1FBQ0E7WUFDRVEsV0FBVztZQUNYVCxrQkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO0tBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS50cz82OGExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcclxuaW1wb3J0IHsgVG9rZW5pemF0aW9uUmVzdWx0LCBUb2tlbml6ZXJPcHRpb25zLCBDb21wcmVzc2lvbkFuYWx5c2lzIH0gZnJvbSAnQC90eXBlcydcclxuXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCdcclxuXHJcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxyXG4gIHRpbWVvdXQ6IDMwMDAwMCwgLy8gNSBtaW51dGVzIGZvciBtYXNzaXZlIGZpbGVzIC0gTk8gTElNSVRTIVxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxufSlcclxuXHJcbi8vIFJlcXVlc3QgaW50ZXJjZXB0b3IgZm9yIGxvZ2dpbmdcclxuYXBpLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcclxuICAoY29uZmlnKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhgQVBJIFJlcXVlc3Q6ICR7Y29uZmlnLm1ldGhvZD8udG9VcHBlckNhc2UoKX0gJHtjb25maWcudXJsfWApXHJcbiAgICByZXR1cm4gY29uZmlnXHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBSZXF1ZXN0IEVycm9yOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4gIH1cclxuKVxyXG5cclxuLy8gUmVzcG9uc2UgaW50ZXJjZXB0b3IgZm9yIGVycm9yIGhhbmRsaW5nXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxyXG4gIChyZXNwb25zZSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coYEFQSSBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2UuY29uZmlnLnVybH1gKVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlXHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBSZXNwb25zZSBFcnJvcjonLCBlcnJvcilcclxuICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA1MDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJylcclxuICAgIH0gZWxzZSBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhPy5kZXRhaWwgfHwgJ0ludmFsaWQgcmVxdWVzdC4nKVxyXG4gICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgZW5kcG9pbnQgbm90IGZvdW5kLiBQbGVhc2UgY2hlY2sgeW91ciBjb25maWd1cmF0aW9uLicpXHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlcXVlc3RzLiBQbGVhc2Ugd2FpdCBhIG1vbWVudCBhbmQgdHJ5IGFnYWluLicpXHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0LiBQbGVhc2UgdHJ5IGFnYWluLicpXHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyLiBQbGVhc2UgY2hlY2sgaWYgdGhlIGJhY2tlbmQgaXMgcnVubmluZy4nKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpXHJcbiAgICB9XHJcbiAgfVxyXG4pXHJcblxyXG5leHBvcnQgY29uc3QgdG9rZW5pemVUZXh0ID0gYXN5bmMgKFxyXG4gIHRleHQ6IHN0cmluZyxcclxuICBvcHRpb25zOiBUb2tlbml6ZXJPcHRpb25zXHJcbik6IFByb21pc2U8VG9rZW5pemF0aW9uUmVzdWx0PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy90b2tlbml6ZScsIHtcclxuICAgICAgdGV4dCxcclxuICAgICAgdG9rZW5pemVyX3R5cGU6IG9wdGlvbnMudG9rZW5pemVyVHlwZSxcclxuICAgICAgbG93ZXI6IG9wdGlvbnMubG93ZXJjYXNlLFxyXG4gICAgICBkcm9wX3NwZWNpYWxzOiBvcHRpb25zLmRyb3BTcGVjaWFscyxcclxuICAgICAgY29sbGFwc2VfcmVwZWF0czogb3B0aW9ucy5jb2xsYXBzZVJlcGVhdHMsXHJcbiAgICAgIGVtYmVkZGluZzogb3B0aW9ucy5lbmFibGVFbWJlZGRpbmcsXHJcbiAgICAgIHNlZWQ6IG9wdGlvbnMuc2VlZCxcclxuICAgICAgZW1iZWRkaW5nX2JpdDogb3B0aW9ucy5lbWJlZGRpbmdCaXQsXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuaXphdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgIGlmIChlcnJvci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dC4gUGxlYXNlIHRyeSB3aXRoIHNob3J0ZXIgdGV4dC4nKVxyXG4gICAgfVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmFseXplVGV4dCA9IGFzeW5jIChcclxuICB0ZXh0OiBzdHJpbmcsXHJcbiAgb3B0aW9uczogVG9rZW5pemVyT3B0aW9uc1xyXG4pOiBQcm9taXNlPHtcclxuICBhbmFseXNpczogYW55XHJcbiAgbWV0cmljczogYW55XHJcbiAgZmluZ2VycHJpbnQ6IGFueVxyXG59PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hbmFseXplJywge1xyXG4gICAgICB0ZXh0LFxyXG4gICAgICB0b2tlbml6ZXJfdHlwZTogb3B0aW9ucy50b2tlbml6ZXJUeXBlLFxyXG4gICAgICBsb3dlcjogb3B0aW9ucy5sb3dlcmNhc2UsXHJcbiAgICAgIGRyb3Bfc3BlY2lhbHM6IG9wdGlvbnMuZHJvcFNwZWNpYWxzLFxyXG4gICAgICBjb2xsYXBzZV9yZXBlYXRzOiBvcHRpb25zLmNvbGxhcHNlUmVwZWF0cyxcclxuICAgICAgZW1iZWRkaW5nOiBvcHRpb25zLmVuYWJsZUVtYmVkZGluZyxcclxuICAgICAgc2VlZDogb3B0aW9ucy5zZWVkLFxyXG4gICAgICBlbWJlZGRpbmdfYml0OiBvcHRpb25zLmVtYmVkZGluZ0JpdCxcclxuICAgIH0pXHJcbiAgICBcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5c2lzIGVycm9yOicsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb21wcmVzc1RleHQgPSBhc3luYyAoXHJcbiAgdGV4dDogc3RyaW5nLFxyXG4gIG9wdGlvbnM6IFRva2VuaXplck9wdGlvbnNcclxuKTogUHJvbWlzZTxDb21wcmVzc2lvbkFuYWx5c2lzW10+ID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2NvbXByZXNzJywge1xyXG4gICAgICB0ZXh0LFxyXG4gICAgICB0b2tlbml6ZXJfdHlwZTogb3B0aW9ucy50b2tlbml6ZXJUeXBlLFxyXG4gICAgICBsb3dlcjogb3B0aW9ucy5sb3dlcmNhc2UsXHJcbiAgICAgIGRyb3Bfc3BlY2lhbHM6IG9wdGlvbnMuZHJvcFNwZWNpYWxzLFxyXG4gICAgICBjb2xsYXBzZV9yZXBlYXRzOiBvcHRpb25zLmNvbGxhcHNlUmVwZWF0cyxcclxuICAgICAgZW1iZWRkaW5nOiBvcHRpb25zLmVuYWJsZUVtYmVkZGluZyxcclxuICAgICAgc2VlZDogb3B0aW9ucy5zZWVkLFxyXG4gICAgICBlbWJlZGRpbmdfYml0OiBvcHRpb25zLmVtYmVkZGluZ0JpdCxcclxuICAgIH0pXHJcbiAgICBcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NvbXByZXNzaW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVRva2VuaXphdGlvbiA9IGFzeW5jIChcclxuICBvcmlnaW5hbFRleHQ6IHN0cmluZyxcclxuICB0b2tlbnM6IGFueVtdLFxyXG4gIG9wdGlvbnM6IFRva2VuaXplck9wdGlvbnNcclxuKTogUHJvbWlzZTx7XHJcbiAgaXNWYWxpZDogYm9vbGVhblxyXG4gIHJldmVyc2liaWxpdHk6IGJvb2xlYW5cclxuICByZWNvbnN0cnVjdGlvbjogc3RyaW5nXHJcbiAgZGlmZmVyZW5jZXM6IHN0cmluZ1tdXHJcbn0+ID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL3ZhbGlkYXRlJywge1xyXG4gICAgICBvcmlnaW5hbF90ZXh0OiBvcmlnaW5hbFRleHQsXHJcbiAgICAgIHRva2VucyxcclxuICAgICAgdG9rZW5pemVyX3R5cGU6IG9wdGlvbnMudG9rZW5pemVyVHlwZSxcclxuICAgICAgbG93ZXI6IG9wdGlvbnMubG93ZXJjYXNlLFxyXG4gICAgICBkcm9wX3NwZWNpYWxzOiBvcHRpb25zLmRyb3BTcGVjaWFscyxcclxuICAgICAgY29sbGFwc2VfcmVwZWF0czogb3B0aW9ucy5jb2xsYXBzZVJlcGVhdHMsXHJcbiAgICAgIGVtYmVkZGluZzogb3B0aW9ucy5lbmFibGVFbWJlZGRpbmcsXHJcbiAgICAgIHNlZWQ6IG9wdGlvbnMuc2VlZCxcclxuICAgICAgZW1iZWRkaW5nX2JpdDogb3B0aW9ucy5lbWJlZGRpbmdCaXQsXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdWYWxpZGF0aW9uIGVycm9yOicsIGVycm9yKVxyXG4gICAgdGhyb3cgZXJyb3JcclxuICB9XHJcbn1cclxuXHJcbi8vIE1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnQgd2hlbiBBUEkgaXMgbm90IGF2YWlsYWJsZVxyXG5leHBvcnQgY29uc3QgZ2V0TW9ja1Rva2VuaXphdGlvblJlc3VsdCA9IChcclxuICB0ZXh0OiBzdHJpbmcsXHJcbiAgb3B0aW9uczogVG9rZW5pemVyT3B0aW9uc1xyXG4pOiBUb2tlbml6YXRpb25SZXN1bHQgPT4ge1xyXG4gIGxldCB0b2tlbnM6IGFueVtdID0gW11cclxuICBcclxuICBzd2l0Y2ggKG9wdGlvbnMudG9rZW5pemVyVHlwZSkge1xyXG4gICAgY2FzZSAnc3BhY2UnOlxyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KC9cXHMrLykuZmlsdGVyKHRva2VuID0+IHRva2VuLmxlbmd0aCA+IDApXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICd3b3JkJzpcclxuICAgICAgLy8gU3BsaXQgb24gd29yZCBib3VuZGFyaWVzLCBrZWVwaW5nIHB1bmN0dWF0aW9uXHJcbiAgICAgIHRva2VucyA9IHRleHQuc3BsaXQoLyhcXFcrKS8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbi5sZW5ndGggPiAwKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnY2hhcic6XHJcbiAgICAgIHRva2VucyA9IHRleHQuc3BsaXQoJycpXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdncmFtbWFyJzpcclxuICAgICAgLy8gR3JhbW1hci1hd2FyZSB0b2tlbml6YXRpb24gLSBzcGxpdCBvbiBzZW50ZW5jZSBib3VuZGFyaWVzXHJcbiAgICAgIHRva2VucyA9IHRleHQuc3BsaXQoLyhbLiE/XSspLykuZmlsdGVyKHRva2VuID0+IHRva2VuLmxlbmd0aCA+IDApXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdzdWJ3b3JkJzpcclxuICAgICAgLy8gU2ltcGxlIHN1YndvcmQgdG9rZW5pemF0aW9uIC0gc3BsaXQgb24gY29tbW9uIHNlcGFyYXRvcnNcclxuICAgICAgdG9rZW5zID0gdGV4dC5zcGxpdCgvKFtcXC9fXFwtXFwuXSkvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubGVuZ3RoID4gMClcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ2JwZSc6XHJcbiAgICAgIC8vIEJ5dGUgUGFpciBFbmNvZGluZyBzaW11bGF0aW9uXHJcbiAgICAgIHRva2VucyA9IHRleHQubWF0Y2goLy57MSwzfS9nKSB8fCBbXVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnc3lsbGFibGUnOlxyXG4gICAgICAvLyBTeWxsYWJsZS1iYXNlZCB0b2tlbml6YXRpb24gc2ltdWxhdGlvblxyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KC8oW2FlaW91QUVJT1VdKykvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubGVuZ3RoID4gMClcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ2ZyZXF1ZW5jeSc6XHJcbiAgICAgIC8vIEZyZXF1ZW5jeS1iYXNlZCB0b2tlbml6YXRpb24gc2ltdWxhdGlvblxyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KC8oW2EtekEtWl0rKS8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbi5sZW5ndGggPiAwKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnYnl0ZSc6XHJcbiAgICAgIC8vIEJ5dGUtbGV2ZWwgdG9rZW5pemF0aW9uXHJcbiAgICAgIHRva2VucyA9IEFycmF5LmZyb20odGV4dCkubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKCkpXHJcbiAgICAgIGJyZWFrXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KC9cXHMrLykuZmlsdGVyKHRva2VuID0+IHRva2VuLmxlbmd0aCA+IDApXHJcbiAgfVxyXG5cclxuICBjb25zdCB0b2tlbk9iamVjdHMgPSB0b2tlbnMubWFwKCh0b2tlbiwgaW5kZXgpID0+ICh7XHJcbiAgICB0ZXh0OiB0b2tlbixcclxuICAgIGlkOiBpbmRleCxcclxuICAgIHBvc2l0aW9uOiB0ZXh0LmluZGV4T2YodG9rZW4pLFxyXG4gICAgbGVuZ3RoOiB0b2tlbi5sZW5ndGgsXHJcbiAgICB0eXBlOiBvcHRpb25zLnRva2VuaXplclR5cGUsXHJcbiAgICBjb2xvcjogYGhzbCgkeyhpbmRleCAqIDEzNy41KSAlIDM2MH0sIDcwJSwgNTAlKWAsXHJcbiAgfSkpXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0b2tlbnM6IHRva2VuT2JqZWN0cyxcclxuICAgIHRva2VuQ291bnQ6IHRva2VuT2JqZWN0cy5sZW5ndGgsXHJcbiAgICBjaGFyYWN0ZXJDb3VudDogdGV4dC5sZW5ndGgsXHJcbiAgICB0b2tlbml6ZXJUeXBlOiBvcHRpb25zLnRva2VuaXplclR5cGUsXHJcbiAgICBwcm9jZXNzaW5nVGltZTogTWF0aC5yYW5kb20oKSAqIDEwMCArIDUwLFxyXG4gICAgbWVtb3J5VXNhZ2U6IE1hdGgucmFuZG9tKCkgKiAxMDI0ICsgNTEyLFxyXG4gICAgY29tcHJlc3Npb25SYXRpbzogTWF0aC5yYW5kb20oKSAqIDAuNSArIDAuMyxcclxuICAgIHJldmVyc2liaWxpdHk6IHRydWUsXHJcbiAgICBmaW5nZXJwcmludDoge1xyXG4gICAgICBzaWduYXR1cmVEaWdpdDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLFxyXG4gICAgICBjb21wYXREaWdpdDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLFxyXG4gICAgICB0ZXh0VmFsdWU6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSxcclxuICAgICAgdGV4dFZhbHVlV2l0aEVtYmVkZGluZzogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLFxyXG4gICAgfSxcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRNb2NrQ29tcHJlc3Npb25BbmFseXNpcyA9ICgpOiBDb21wcmVzc2lvbkFuYWx5c2lzW10gPT4gW1xyXG4gIHtcclxuICAgIGFsZ29yaXRobTogJ1JMRScsXHJcbiAgICBjb21wcmVzc2lvblJhdGlvOiAwLjQ1LFxyXG4gICAgdG9rZW5zU2F2ZWQ6IDEyMCxcclxuICAgIHBlcmNlbnRhZ2VTYXZlZDogMzUuMixcclxuICAgIHJldmVyc2liaWxpdHk6IHRydWUsXHJcbiAgfSxcclxuICB7XHJcbiAgICBhbGdvcml0aG06ICdQYXR0ZXJuJyxcclxuICAgIGNvbXByZXNzaW9uUmF0aW86IDAuMzgsXHJcbiAgICB0b2tlbnNTYXZlZDogMTQ1LFxyXG4gICAgcGVyY2VudGFnZVNhdmVkOiA0Mi4xLFxyXG4gICAgcmV2ZXJzaWJpbGl0eTogdHJ1ZSxcclxuICB9LFxyXG4gIHtcclxuICAgIGFsZ29yaXRobTogJ0ZyZXF1ZW5jeScsXHJcbiAgICBjb21wcmVzc2lvblJhdGlvOiAwLjUyLFxyXG4gICAgdG9rZW5zU2F2ZWQ6IDk4LFxyXG4gICAgcGVyY2VudGFnZVNhdmVkOiAyOC43LFxyXG4gICAgcmV2ZXJzaWJpbGl0eTogdHJ1ZSxcclxuICB9LFxyXG4gIHtcclxuICAgIGFsZ29yaXRobTogJ0FkYXB0aXZlJyxcclxuICAgIGNvbXByZXNzaW9uUmF0aW86IDAuMzEsXHJcbiAgICB0b2tlbnNTYXZlZDogMTc4LFxyXG4gICAgcGVyY2VudGFnZVNhdmVkOiA1MS44LFxyXG4gICAgcmV2ZXJzaWJpbGl0eTogdHJ1ZSxcclxuICB9LFxyXG5dXHJcbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiYXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsImNvbnNvbGUiLCJsb2ciLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsInVybCIsImVycm9yIiwiUHJvbWlzZSIsInJlamVjdCIsInJlc3BvbnNlIiwic3RhdHVzIiwiRXJyb3IiLCJkYXRhIiwiZGV0YWlsIiwiY29kZSIsInRva2VuaXplVGV4dCIsInRleHQiLCJvcHRpb25zIiwicG9zdCIsInRva2VuaXplcl90eXBlIiwidG9rZW5pemVyVHlwZSIsImxvd2VyIiwibG93ZXJjYXNlIiwiZHJvcF9zcGVjaWFscyIsImRyb3BTcGVjaWFscyIsImNvbGxhcHNlX3JlcGVhdHMiLCJjb2xsYXBzZVJlcGVhdHMiLCJlbWJlZGRpbmciLCJlbmFibGVFbWJlZGRpbmciLCJzZWVkIiwiZW1iZWRkaW5nX2JpdCIsImVtYmVkZGluZ0JpdCIsImFuYWx5emVUZXh0IiwiY29tcHJlc3NUZXh0IiwidmFsaWRhdGVUb2tlbml6YXRpb24iLCJvcmlnaW5hbFRleHQiLCJ0b2tlbnMiLCJvcmlnaW5hbF90ZXh0IiwiZ2V0TW9ja1Rva2VuaXphdGlvblJlc3VsdCIsInNwbGl0IiwiZmlsdGVyIiwidG9rZW4iLCJsZW5ndGgiLCJtYXRjaCIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImNoYXIiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJ0b2tlbk9iamVjdHMiLCJpbmRleCIsImlkIiwicG9zaXRpb24iLCJpbmRleE9mIiwidHlwZSIsImNvbG9yIiwidG9rZW5Db3VudCIsImNoYXJhY3RlckNvdW50IiwicHJvY2Vzc2luZ1RpbWUiLCJNYXRoIiwicmFuZG9tIiwibWVtb3J5VXNhZ2UiLCJjb21wcmVzc2lvblJhdGlvIiwicmV2ZXJzaWJpbGl0eSIsImZpbmdlcnByaW50Iiwic2lnbmF0dXJlRGlnaXQiLCJmbG9vciIsImNvbXBhdERpZ2l0IiwidGV4dFZhbHVlIiwidGV4dFZhbHVlV2l0aEVtYmVkZGluZyIsImdldE1vY2tDb21wcmVzc2lvbkFuYWx5c2lzIiwiYWxnb3JpdGhtIiwidG9rZW5zU2F2ZWQiLCJwZXJjZW50YWdlU2F2ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});