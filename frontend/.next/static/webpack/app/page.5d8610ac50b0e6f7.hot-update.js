"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeText: function() { return /* binding */ analyzeText; },\n/* harmony export */   compressText: function() { return /* binding */ compressText; },\n/* harmony export */   getMockCompressionAnalysis: function() { return /* binding */ getMockCompressionAnalysis; },\n/* harmony export */   getMockTokenizationResult: function() { return /* binding */ getMockTokenizationResult; },\n/* harmony export */   tokenizeText: function() { return /* binding */ tokenizeText; },\n/* harmony export */   validateTokenization: function() { return /* binding */ validateTokenization; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nconst API_BASE_URL = \"http://localhost:8000\" || 0;\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    timeout: 300000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Request interceptor for logging\napi.interceptors.request.use((config)=>{\n    var _config_method;\n    console.log(\"API Request: \".concat((_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase(), \" \").concat(config.url));\n    return config;\n}, (error)=>{\n    console.error(\"API Request Error:\", error);\n    return Promise.reject(error);\n});\n// Response interceptor for error handling\napi.interceptors.response.use((response)=>{\n    console.log(\"API Response: \".concat(response.status, \" \").concat(response.config.url));\n    return response;\n}, (error)=>{\n    var _error_response, _error_response1, _error_response2, _error_response3;\n    console.error(\"API Response Error:\", error);\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 500) {\n        throw new Error(\"Server error. Please try again later.\");\n    } else if (((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 400) {\n        var _error_response_data;\n        throw new Error(((_error_response_data = error.response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) || \"Invalid request.\");\n    } else if (((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.status) === 404) {\n        throw new Error(\"API endpoint not found. Please check your configuration.\");\n    } else if (((_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status) === 429) {\n        throw new Error(\"Too many requests. Please wait a moment and try again.\");\n    } else if (error.code === \"ECONNABORTED\") {\n        throw new Error(\"Request timeout. Please try again.\");\n    } else if (error.code === \"ECONNREFUSED\") {\n        throw new Error(\"Cannot connect to server. Please check if the backend is running.\");\n    } else {\n        throw new Error(\"Network error. Please check your connection.\");\n    }\n});\nconst tokenizeText = async (text, options)=>{\n    try {\n        console.log(\"Making API request to:\", API_BASE_URL + \"/tokenize\");\n        console.log(\"Request payload:\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        const response = await api.post(\"/tokenize\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        console.log(\"API response received:\", response.data);\n        return response.data;\n    } catch (error) {\n        var _error_response, _error_response1, _error_response2, _error_config, _error_config1;\n        console.error(\"Tokenization error details:\", {\n            message: error.message,\n            code: error.code,\n            status: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status,\n            statusText: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.statusText,\n            data: (_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data,\n            url: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url,\n            baseURL: (_error_config1 = error.config) === null || _error_config1 === void 0 ? void 0 : _error_config1.baseURL\n        });\n        if (error.code === \"ECONNABORTED\") {\n            throw new Error(\"Request timeout. Please try with shorter text.\");\n        }\n        throw error;\n    }\n};\nconst analyzeText = async (text, options)=>{\n    try {\n        const response = await api.post(\"/analyze\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Analysis error:\", error);\n        throw error;\n    }\n};\nconst compressText = async (text, options)=>{\n    try {\n        const response = await api.post(\"/compress\", {\n            text,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Compression error:\", error);\n        throw error;\n    }\n};\nconst validateTokenization = async (originalText, tokens, options)=>{\n    try {\n        const response = await api.post(\"/validate\", {\n            original_text: originalText,\n            tokens,\n            tokenizer_type: options.tokenizerType,\n            lower: options.lowercase,\n            drop_specials: options.dropSpecials,\n            collapse_repeats: options.collapseRepeats,\n            embedding: options.enableEmbedding,\n            seed: options.seed,\n            embedding_bit: options.embeddingBit\n        });\n        return response.data;\n    } catch (error) {\n        console.error(\"Validation error:\", error);\n        throw error;\n    }\n};\n// Mock data for development when API is not available\nconst getMockTokenizationResult = (text, options)=>{\n    let tokens = [];\n    switch(options.tokenizerType){\n        case \"space\":\n            tokens = text.split(/\\s+/).filter((token)=>token.length > 0);\n            break;\n        case \"word\":\n            // Split on word boundaries, keeping punctuation\n            tokens = text.split(/(\\W+)/).filter((token)=>token.length > 0);\n            break;\n        case \"char\":\n            tokens = text.split(\"\");\n            break;\n        case \"grammar\":\n            // Grammar-aware tokenization - split on sentence boundaries\n            tokens = text.split(/([.!?]+)/).filter((token)=>token.length > 0);\n            break;\n        case \"subword\":\n            // Simple subword tokenization - split on common separators\n            tokens = text.split(/([\\/_\\-\\.])/).filter((token)=>token.length > 0);\n            break;\n        case \"bpe\":\n            // Byte Pair Encoding simulation\n            tokens = text.match(/.{1,3}/g) || [];\n            break;\n        case \"syllable\":\n            // Syllable-based tokenization simulation\n            tokens = text.split(/([aeiouAEIOU]+)/).filter((token)=>token.length > 0);\n            break;\n        case \"frequency\":\n            // Frequency-based tokenization simulation\n            tokens = text.split(/([a-zA-Z]+)/).filter((token)=>token.length > 0);\n            break;\n        case \"byte\":\n            // Byte-level tokenization\n            tokens = Array.from(text).map((char)=>char.charCodeAt(0).toString());\n            break;\n        default:\n            tokens = text.split(/\\s+/).filter((token)=>token.length > 0);\n    }\n    const tokenObjects = tokens.map((token, index)=>({\n            text: token,\n            id: index,\n            position: text.indexOf(token),\n            length: token.length,\n            type: options.tokenizerType,\n            color: \"hsl(\".concat(index * 137.5 % 360, \", 70%, 50%)\")\n        }));\n    return {\n        tokens: tokenObjects,\n        tokenCount: tokenObjects.length,\n        characterCount: text.length,\n        tokenizerType: options.tokenizerType,\n        processingTime: Math.random() * 100 + 50,\n        memoryUsage: Math.random() * 1024 + 512,\n        compressionRatio: Math.random() * 0.5 + 0.3,\n        reversibility: true,\n        fingerprint: {\n            signatureDigit: Math.floor(Math.random() * 10),\n            compatDigit: Math.floor(Math.random() * 10),\n            textValue: Math.floor(Math.random() * 10000),\n            textValueWithEmbedding: Math.floor(Math.random() * 10000)\n        }\n    };\n};\nconst getMockCompressionAnalysis = ()=>[\n        {\n            algorithm: \"RLE\",\n            compressionRatio: 0.45,\n            tokensSaved: 120,\n            percentageSaved: 35.2,\n            reversibility: true\n        },\n        {\n            algorithm: \"Pattern\",\n            compressionRatio: 0.38,\n            tokensSaved: 145,\n            percentageSaved: 42.1,\n            reversibility: true\n        },\n        {\n            algorithm: \"Frequency\",\n            compressionRatio: 0.52,\n            tokensSaved: 98,\n            percentageSaved: 28.7,\n            reversibility: true\n        },\n        {\n            algorithm: \"Adaptive\",\n            compressionRatio: 0.31,\n            tokensSaved: 178,\n            percentageSaved: 51.8,\n            reversibility: true\n        }\n    ];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO1FBQ0E7WUFDRVEsV0FBVztZQUNYVCxrQkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO1FBQ0E7WUFDRVEsV0FBVztZQUNYVCxrQkFBa0I7WUFDbEJVLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCVixlQUFlO1FBQ2pCO0tBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS50cz82OGExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcclxuaW1wb3J0IHsgVG9rZW5pemF0aW9uUmVzdWx0LCBUb2tlbml6ZXJPcHRpb25zLCBDb21wcmVzc2lvbkFuYWx5c2lzIH0gZnJvbSAnQC90eXBlcydcclxuXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMCdcclxuXHJcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XHJcbiAgYmFzZVVSTDogQVBJX0JBU0VfVVJMLFxyXG4gIHRpbWVvdXQ6IDMwMDAwMCwgLy8gNSBtaW51dGVzIGZvciBtYXNzaXZlIGZpbGVzIC0gTk8gTElNSVRTIVxyXG4gIGhlYWRlcnM6IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfSxcclxufSlcclxuXHJcbi8vIFJlcXVlc3QgaW50ZXJjZXB0b3IgZm9yIGxvZ2dpbmdcclxuYXBpLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcclxuICAoY29uZmlnKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhgQVBJIFJlcXVlc3Q6ICR7Y29uZmlnLm1ldGhvZD8udG9VcHBlckNhc2UoKX0gJHtjb25maWcudXJsfWApXHJcbiAgICByZXR1cm4gY29uZmlnXHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBSZXF1ZXN0IEVycm9yOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKVxyXG4gIH1cclxuKVxyXG5cclxuLy8gUmVzcG9uc2UgaW50ZXJjZXB0b3IgZm9yIGVycm9yIGhhbmRsaW5nXHJcbmFwaS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxyXG4gIChyZXNwb25zZSkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coYEFQSSBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2UuY29uZmlnLnVybH1gKVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlXHJcbiAgfSxcclxuICAoZXJyb3IpID0+IHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBSZXNwb25zZSBFcnJvcjonLCBlcnJvcilcclxuICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA1MDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJylcclxuICAgIH0gZWxzZSBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhPy5kZXRhaWwgfHwgJ0ludmFsaWQgcmVxdWVzdC4nKVxyXG4gICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgZW5kcG9pbnQgbm90IGZvdW5kLiBQbGVhc2UgY2hlY2sgeW91ciBjb25maWd1cmF0aW9uLicpXHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlcXVlc3RzLiBQbGVhc2Ugd2FpdCBhIG1vbWVudCBhbmQgdHJ5IGFnYWluLicpXHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCB0aW1lb3V0LiBQbGVhc2UgdHJ5IGFnYWluLicpXHJcbiAgICB9IGVsc2UgaWYgKGVycm9yLmNvZGUgPT09ICdFQ09OTlJFRlVTRUQnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyLiBQbGVhc2UgY2hlY2sgaWYgdGhlIGJhY2tlbmQgaXMgcnVubmluZy4nKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpXHJcbiAgICB9XHJcbiAgfVxyXG4pXHJcblxyXG5leHBvcnQgY29uc3QgdG9rZW5pemVUZXh0ID0gYXN5bmMgKFxyXG4gIHRleHQ6IHN0cmluZyxcclxuICBvcHRpb25zOiBUb2tlbml6ZXJPcHRpb25zXHJcbik6IFByb21pc2U8VG9rZW5pemF0aW9uUmVzdWx0PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnNvbGUubG9nKCdNYWtpbmcgQVBJIHJlcXVlc3QgdG86JywgQVBJX0JBU0VfVVJMICsgJy90b2tlbml6ZScpXHJcbiAgICBjb25zb2xlLmxvZygnUmVxdWVzdCBwYXlsb2FkOicsIHtcclxuICAgICAgdGV4dCxcclxuICAgICAgdG9rZW5pemVyX3R5cGU6IG9wdGlvbnMudG9rZW5pemVyVHlwZSxcclxuICAgICAgbG93ZXI6IG9wdGlvbnMubG93ZXJjYXNlLFxyXG4gICAgICBkcm9wX3NwZWNpYWxzOiBvcHRpb25zLmRyb3BTcGVjaWFscyxcclxuICAgICAgY29sbGFwc2VfcmVwZWF0czogb3B0aW9ucy5jb2xsYXBzZVJlcGVhdHMsXHJcbiAgICAgIGVtYmVkZGluZzogb3B0aW9ucy5lbmFibGVFbWJlZGRpbmcsXHJcbiAgICAgIHNlZWQ6IG9wdGlvbnMuc2VlZCxcclxuICAgICAgZW1iZWRkaW5nX2JpdDogb3B0aW9ucy5lbWJlZGRpbmdCaXQsXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvdG9rZW5pemUnLCB7XHJcbiAgICAgIHRleHQsXHJcbiAgICAgIHRva2VuaXplcl90eXBlOiBvcHRpb25zLnRva2VuaXplclR5cGUsXHJcbiAgICAgIGxvd2VyOiBvcHRpb25zLmxvd2VyY2FzZSxcclxuICAgICAgZHJvcF9zcGVjaWFsczogb3B0aW9ucy5kcm9wU3BlY2lhbHMsXHJcbiAgICAgIGNvbGxhcHNlX3JlcGVhdHM6IG9wdGlvbnMuY29sbGFwc2VSZXBlYXRzLFxyXG4gICAgICBlbWJlZGRpbmc6IG9wdGlvbnMuZW5hYmxlRW1iZWRkaW5nLFxyXG4gICAgICBzZWVkOiBvcHRpb25zLnNlZWQsXHJcbiAgICAgIGVtYmVkZGluZ19iaXQ6IG9wdGlvbnMuZW1iZWRkaW5nQml0LFxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0FQSSByZXNwb25zZSByZWNlaXZlZDonLCByZXNwb25zZS5kYXRhKVxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdUb2tlbml6YXRpb24gZXJyb3IgZGV0YWlsczonLCB7XHJcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgIGNvZGU6IGVycm9yLmNvZGUsXHJcbiAgICAgIHN0YXR1czogZXJyb3IucmVzcG9uc2U/LnN0YXR1cyxcclxuICAgICAgc3RhdHVzVGV4dDogZXJyb3IucmVzcG9uc2U/LnN0YXR1c1RleHQsXHJcbiAgICAgIGRhdGE6IGVycm9yLnJlc3BvbnNlPy5kYXRhLFxyXG4gICAgICB1cmw6IGVycm9yLmNvbmZpZz8udXJsLFxyXG4gICAgICBiYXNlVVJMOiBlcnJvci5jb25maWc/LmJhc2VVUkxcclxuICAgIH0pXHJcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQuIFBsZWFzZSB0cnkgd2l0aCBzaG9ydGVyIHRleHQuJylcclxuICAgIH1cclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5hbHl6ZVRleHQgPSBhc3luYyAoXHJcbiAgdGV4dDogc3RyaW5nLFxyXG4gIG9wdGlvbnM6IFRva2VuaXplck9wdGlvbnNcclxuKTogUHJvbWlzZTx7XHJcbiAgYW5hbHlzaXM6IGFueVxyXG4gIG1ldHJpY3M6IGFueVxyXG4gIGZpbmdlcnByaW50OiBhbnlcclxufT4gPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYW5hbHl6ZScsIHtcclxuICAgICAgdGV4dCxcclxuICAgICAgdG9rZW5pemVyX3R5cGU6IG9wdGlvbnMudG9rZW5pemVyVHlwZSxcclxuICAgICAgbG93ZXI6IG9wdGlvbnMubG93ZXJjYXNlLFxyXG4gICAgICBkcm9wX3NwZWNpYWxzOiBvcHRpb25zLmRyb3BTcGVjaWFscyxcclxuICAgICAgY29sbGFwc2VfcmVwZWF0czogb3B0aW9ucy5jb2xsYXBzZVJlcGVhdHMsXHJcbiAgICAgIGVtYmVkZGluZzogb3B0aW9ucy5lbmFibGVFbWJlZGRpbmcsXHJcbiAgICAgIHNlZWQ6IG9wdGlvbnMuc2VlZCxcclxuICAgICAgZW1iZWRkaW5nX2JpdDogb3B0aW9ucy5lbWJlZGRpbmdCaXQsXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdBbmFseXNpcyBlcnJvcjonLCBlcnJvcilcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgY29tcHJlc3NUZXh0ID0gYXN5bmMgKFxyXG4gIHRleHQ6IHN0cmluZyxcclxuICBvcHRpb25zOiBUb2tlbml6ZXJPcHRpb25zXHJcbik6IFByb21pc2U8Q29tcHJlc3Npb25BbmFseXNpc1tdPiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9jb21wcmVzcycsIHtcclxuICAgICAgdGV4dCxcclxuICAgICAgdG9rZW5pemVyX3R5cGU6IG9wdGlvbnMudG9rZW5pemVyVHlwZSxcclxuICAgICAgbG93ZXI6IG9wdGlvbnMubG93ZXJjYXNlLFxyXG4gICAgICBkcm9wX3NwZWNpYWxzOiBvcHRpb25zLmRyb3BTcGVjaWFscyxcclxuICAgICAgY29sbGFwc2VfcmVwZWF0czogb3B0aW9ucy5jb2xsYXBzZVJlcGVhdHMsXHJcbiAgICAgIGVtYmVkZGluZzogb3B0aW9ucy5lbmFibGVFbWJlZGRpbmcsXHJcbiAgICAgIHNlZWQ6IG9wdGlvbnMuc2VlZCxcclxuICAgICAgZW1iZWRkaW5nX2JpdDogb3B0aW9ucy5lbWJlZGRpbmdCaXQsXHJcbiAgICB9KVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdDb21wcmVzc2lvbiBlcnJvcjonLCBlcnJvcilcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVUb2tlbml6YXRpb24gPSBhc3luYyAoXHJcbiAgb3JpZ2luYWxUZXh0OiBzdHJpbmcsXHJcbiAgdG9rZW5zOiBhbnlbXSxcclxuICBvcHRpb25zOiBUb2tlbml6ZXJPcHRpb25zXHJcbik6IFByb21pc2U8e1xyXG4gIGlzVmFsaWQ6IGJvb2xlYW5cclxuICByZXZlcnNpYmlsaXR5OiBib29sZWFuXHJcbiAgcmVjb25zdHJ1Y3Rpb246IHN0cmluZ1xyXG4gIGRpZmZlcmVuY2VzOiBzdHJpbmdbXVxyXG59PiA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy92YWxpZGF0ZScsIHtcclxuICAgICAgb3JpZ2luYWxfdGV4dDogb3JpZ2luYWxUZXh0LFxyXG4gICAgICB0b2tlbnMsXHJcbiAgICAgIHRva2VuaXplcl90eXBlOiBvcHRpb25zLnRva2VuaXplclR5cGUsXHJcbiAgICAgIGxvd2VyOiBvcHRpb25zLmxvd2VyY2FzZSxcclxuICAgICAgZHJvcF9zcGVjaWFsczogb3B0aW9ucy5kcm9wU3BlY2lhbHMsXHJcbiAgICAgIGNvbGxhcHNlX3JlcGVhdHM6IG9wdGlvbnMuY29sbGFwc2VSZXBlYXRzLFxyXG4gICAgICBlbWJlZGRpbmc6IG9wdGlvbnMuZW5hYmxlRW1iZWRkaW5nLFxyXG4gICAgICBzZWVkOiBvcHRpb25zLnNlZWQsXHJcbiAgICAgIGVtYmVkZGluZ19iaXQ6IG9wdGlvbnMuZW1iZWRkaW5nQml0LFxyXG4gICAgfSlcclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignVmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcilcclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG59XHJcblxyXG4vLyBNb2NrIGRhdGEgZm9yIGRldmVsb3BtZW50IHdoZW4gQVBJIGlzIG5vdCBhdmFpbGFibGVcclxuZXhwb3J0IGNvbnN0IGdldE1vY2tUb2tlbml6YXRpb25SZXN1bHQgPSAoXHJcbiAgdGV4dDogc3RyaW5nLFxyXG4gIG9wdGlvbnM6IFRva2VuaXplck9wdGlvbnNcclxuKTogVG9rZW5pemF0aW9uUmVzdWx0ID0+IHtcclxuICBsZXQgdG9rZW5zOiBhbnlbXSA9IFtdXHJcbiAgXHJcbiAgc3dpdGNoIChvcHRpb25zLnRva2VuaXplclR5cGUpIHtcclxuICAgIGNhc2UgJ3NwYWNlJzpcclxuICAgICAgdG9rZW5zID0gdGV4dC5zcGxpdCgvXFxzKy8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbi5sZW5ndGggPiAwKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnd29yZCc6XHJcbiAgICAgIC8vIFNwbGl0IG9uIHdvcmQgYm91bmRhcmllcywga2VlcGluZyBwdW5jdHVhdGlvblxyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KC8oXFxXKykvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubGVuZ3RoID4gMClcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ2NoYXInOlxyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KCcnKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnZ3JhbW1hcic6XHJcbiAgICAgIC8vIEdyYW1tYXItYXdhcmUgdG9rZW5pemF0aW9uIC0gc3BsaXQgb24gc2VudGVuY2UgYm91bmRhcmllc1xyXG4gICAgICB0b2tlbnMgPSB0ZXh0LnNwbGl0KC8oWy4hP10rKS8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbi5sZW5ndGggPiAwKVxyXG4gICAgICBicmVha1xyXG4gICAgY2FzZSAnc3Vid29yZCc6XHJcbiAgICAgIC8vIFNpbXBsZSBzdWJ3b3JkIHRva2VuaXphdGlvbiAtIHNwbGl0IG9uIGNvbW1vbiBzZXBhcmF0b3JzXHJcbiAgICAgIHRva2VucyA9IHRleHQuc3BsaXQoLyhbXFwvX1xcLVxcLl0pLykuZmlsdGVyKHRva2VuID0+IHRva2VuLmxlbmd0aCA+IDApXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdicGUnOlxyXG4gICAgICAvLyBCeXRlIFBhaXIgRW5jb2Rpbmcgc2ltdWxhdGlvblxyXG4gICAgICB0b2tlbnMgPSB0ZXh0Lm1hdGNoKC8uezEsM30vZykgfHwgW11cclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ3N5bGxhYmxlJzpcclxuICAgICAgLy8gU3lsbGFibGUtYmFzZWQgdG9rZW5pemF0aW9uIHNpbXVsYXRpb25cclxuICAgICAgdG9rZW5zID0gdGV4dC5zcGxpdCgvKFthZWlvdUFFSU9VXSspLykuZmlsdGVyKHRva2VuID0+IHRva2VuLmxlbmd0aCA+IDApXHJcbiAgICAgIGJyZWFrXHJcbiAgICBjYXNlICdmcmVxdWVuY3knOlxyXG4gICAgICAvLyBGcmVxdWVuY3ktYmFzZWQgdG9rZW5pemF0aW9uIHNpbXVsYXRpb25cclxuICAgICAgdG9rZW5zID0gdGV4dC5zcGxpdCgvKFthLXpBLVpdKykvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubGVuZ3RoID4gMClcclxuICAgICAgYnJlYWtcclxuICAgIGNhc2UgJ2J5dGUnOlxyXG4gICAgICAvLyBCeXRlLWxldmVsIHRva2VuaXphdGlvblxyXG4gICAgICB0b2tlbnMgPSBBcnJheS5mcm9tKHRleHQpLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygpKVxyXG4gICAgICBicmVha1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdG9rZW5zID0gdGV4dC5zcGxpdCgvXFxzKy8pLmZpbHRlcih0b2tlbiA9PiB0b2tlbi5sZW5ndGggPiAwKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdG9rZW5PYmplY3RzID0gdG9rZW5zLm1hcCgodG9rZW4sIGluZGV4KSA9PiAoe1xyXG4gICAgdGV4dDogdG9rZW4sXHJcbiAgICBpZDogaW5kZXgsXHJcbiAgICBwb3NpdGlvbjogdGV4dC5pbmRleE9mKHRva2VuKSxcclxuICAgIGxlbmd0aDogdG9rZW4ubGVuZ3RoLFxyXG4gICAgdHlwZTogb3B0aW9ucy50b2tlbml6ZXJUeXBlLFxyXG4gICAgY29sb3I6IGBoc2woJHsoaW5kZXggKiAxMzcuNSkgJSAzNjB9LCA3MCUsIDUwJSlgLFxyXG4gIH0pKVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdG9rZW5zOiB0b2tlbk9iamVjdHMsXHJcbiAgICB0b2tlbkNvdW50OiB0b2tlbk9iamVjdHMubGVuZ3RoLFxyXG4gICAgY2hhcmFjdGVyQ291bnQ6IHRleHQubGVuZ3RoLFxyXG4gICAgdG9rZW5pemVyVHlwZTogb3B0aW9ucy50b2tlbml6ZXJUeXBlLFxyXG4gICAgcHJvY2Vzc2luZ1RpbWU6IE1hdGgucmFuZG9tKCkgKiAxMDAgKyA1MCxcclxuICAgIG1lbW9yeVVzYWdlOiBNYXRoLnJhbmRvbSgpICogMTAyNCArIDUxMixcclxuICAgIGNvbXByZXNzaW9uUmF0aW86IE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjMsXHJcbiAgICByZXZlcnNpYmlsaXR5OiB0cnVlLFxyXG4gICAgZmluZ2VycHJpbnQ6IHtcclxuICAgICAgc2lnbmF0dXJlRGlnaXQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSxcclxuICAgICAgY29tcGF0RGlnaXQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSxcclxuICAgICAgdGV4dFZhbHVlOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCksXHJcbiAgICAgIHRleHRWYWx1ZVdpdGhFbWJlZGRpbmc6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSxcclxuICAgIH0sXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0TW9ja0NvbXByZXNzaW9uQW5hbHlzaXMgPSAoKTogQ29tcHJlc3Npb25BbmFseXNpc1tdID0+IFtcclxuICB7XHJcbiAgICBhbGdvcml0aG06ICdSTEUnLFxyXG4gICAgY29tcHJlc3Npb25SYXRpbzogMC40NSxcclxuICAgIHRva2Vuc1NhdmVkOiAxMjAsXHJcbiAgICBwZXJjZW50YWdlU2F2ZWQ6IDM1LjIsXHJcbiAgICByZXZlcnNpYmlsaXR5OiB0cnVlLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgYWxnb3JpdGhtOiAnUGF0dGVybicsXHJcbiAgICBjb21wcmVzc2lvblJhdGlvOiAwLjM4LFxyXG4gICAgdG9rZW5zU2F2ZWQ6IDE0NSxcclxuICAgIHBlcmNlbnRhZ2VTYXZlZDogNDIuMSxcclxuICAgIHJldmVyc2liaWxpdHk6IHRydWUsXHJcbiAgfSxcclxuICB7XHJcbiAgICBhbGdvcml0aG06ICdGcmVxdWVuY3knLFxyXG4gICAgY29tcHJlc3Npb25SYXRpbzogMC41MixcclxuICAgIHRva2Vuc1NhdmVkOiA5OCxcclxuICAgIHBlcmNlbnRhZ2VTYXZlZDogMjguNyxcclxuICAgIHJldmVyc2liaWxpdHk6IHRydWUsXHJcbiAgfSxcclxuICB7XHJcbiAgICBhbGdvcml0aG06ICdBZGFwdGl2ZScsXHJcbiAgICBjb21wcmVzc2lvblJhdGlvOiAwLjMxLFxyXG4gICAgdG9rZW5zU2F2ZWQ6IDE3OCxcclxuICAgIHBlcmNlbnRhZ2VTYXZlZDogNTEuOCxcclxuICAgIHJldmVyc2liaWxpdHk6IHRydWUsXHJcbiAgfSxcclxuXVxyXG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJ1cmwiLCJlcnJvciIsIlByb21pc2UiLCJyZWplY3QiLCJyZXNwb25zZSIsInN0YXR1cyIsIkVycm9yIiwiZGF0YSIsImRldGFpbCIsImNvZGUiLCJ0b2tlbml6ZVRleHQiLCJ0ZXh0Iiwib3B0aW9ucyIsInRva2VuaXplcl90eXBlIiwidG9rZW5pemVyVHlwZSIsImxvd2VyIiwibG93ZXJjYXNlIiwiZHJvcF9zcGVjaWFscyIsImRyb3BTcGVjaWFscyIsImNvbGxhcHNlX3JlcGVhdHMiLCJjb2xsYXBzZVJlcGVhdHMiLCJlbWJlZGRpbmciLCJlbmFibGVFbWJlZGRpbmciLCJzZWVkIiwiZW1iZWRkaW5nX2JpdCIsImVtYmVkZGluZ0JpdCIsInBvc3QiLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsImFuYWx5emVUZXh0IiwiY29tcHJlc3NUZXh0IiwidmFsaWRhdGVUb2tlbml6YXRpb24iLCJvcmlnaW5hbFRleHQiLCJ0b2tlbnMiLCJvcmlnaW5hbF90ZXh0IiwiZ2V0TW9ja1Rva2VuaXphdGlvblJlc3VsdCIsInNwbGl0IiwiZmlsdGVyIiwidG9rZW4iLCJsZW5ndGgiLCJtYXRjaCIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImNoYXIiLCJjaGFyQ29kZUF0IiwidG9TdHJpbmciLCJ0b2tlbk9iamVjdHMiLCJpbmRleCIsImlkIiwicG9zaXRpb24iLCJpbmRleE9mIiwidHlwZSIsImNvbG9yIiwidG9rZW5Db3VudCIsImNoYXJhY3RlckNvdW50IiwicHJvY2Vzc2luZ1RpbWUiLCJNYXRoIiwicmFuZG9tIiwibWVtb3J5VXNhZ2UiLCJjb21wcmVzc2lvblJhdGlvIiwicmV2ZXJzaWJpbGl0eSIsImZpbmdlcnByaW50Iiwic2lnbmF0dXJlRGlnaXQiLCJmbG9vciIsImNvbXBhdERpZ2l0IiwidGV4dFZhbHVlIiwidGV4dFZhbHVlV2l0aEVtYmVkZGluZyIsImdldE1vY2tDb21wcmVzc2lvbkFuYWx5c2lzIiwiYWxnb3JpdGhtIiwidG9rZW5zU2F2ZWQiLCJwZXJjZW50YWdlU2F2ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});